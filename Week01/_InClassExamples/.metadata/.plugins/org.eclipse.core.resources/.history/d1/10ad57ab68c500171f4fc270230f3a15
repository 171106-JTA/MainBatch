package com.revature.model;

import java.io.*;
import java.io.Serializable;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.revature.exception.*;
import com.revature.model.account.*;
import com.revature.model.request.*;

public class Model implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -1246053592029216131L;

	private static final String letterRegex = "^[a-zA-Z]";
	private static final String numberRegex = "^[0-9]";
	private static final String specCharRegex = "[a-zA-Z0-9 ]";

	private static Model m;
	private static Set<String> sessions = Collections.synchronizedSet(new HashSet<String>());
	private static String modelFile = Constants.FILENAME;
	private Map<String, UserAccount> users;
	private Map<String, UserAccount> lockedAccounts;
	private Map<String, UserAccount> unlockedAccounts;
	private Map<String, AdminAccount> admins;
	private Map<String, UserAccount> rejectedUsers;
	private Map<Integer, Request> requests;
	private Map<Integer, AccountRequest> accountRequests;
	private Map<Integer, LoanRequest> loanRequests;
	private Map<Integer, CancelRequest> rollbackRequests;
	private Map<Integer, LoanRequest> approvedLoans;

	private Model() {
		users = new HashMap<String, UserAccount>();
		admins = new HashMap<String, AdminAccount>();
		rejectedUsers = new HashMap<String, UserAccount>();
		requests = new HashMap<Integer, Request>();
		accountRequests = new HashMap<Integer, AccountRequest>();
		loanRequests = new HashMap<Integer, LoanRequest>();
		rollbackRequests = new HashMap<Integer, CancelRequest>();
		approvedLoans = new HashMap<Integer, LoanRequest>();
		queryUsers(Constants.PROT_ADD, Constants.ROOT_ADMIN_USER, RootUserAccount.class, Constants.ROOT_ADMIN_USER,
				Constants.ROOT_ADMIN_PASS, Constants.ROOT_USER_BAL);
		queryAdmins(Constants.PROT_ADD, Constants.ROOT_ADMIN_USER, AdminAccount.class, Constants.ROOT_ADMIN_USER,
				Constants.ROOT_ADMIN_PASS, users.get(Constants.ROOT_ADMIN_USER));
	}

	public static Model getInstance() {
		File file = new File(modelFile);
		try {
			file.createNewFile();
			deserialize();
		} catch (IOException | ClassNotFoundException e) {
			System.out.println(e.getMessage());
			if (Constants.DEBUG)
				e.printStackTrace();
		} finally {
			if (m == null)
				m = new Model();
		}
		return m;
	}

	// Query methods
	public synchronized Object queryUsers(int prot, String user, Object... args) {
		return queryList(prot, users, user, UserAccount.class, args);
	}

	public synchronized Object queryAdmins(int prot, String admin, Object... args) {
		return queryList(prot, admins, admin, AdminAccount.class, args);
	}

	public synchronized Object queryRequests(int prot, int id, Object... args) {
		return queryList(prot, requests, id, Request.class, args);
	}

	public synchronized Object queryLockedAccounts(int prot, String user, UserAccount ua) {
		return queryList(prot, lockedAccounts, user, ua);
	}

	public synchronized Object queryUnlockedAccounts(int prot, String user, UserAccount ua) {
		return queryList(prot, unlockedAccounts, user, ua);
	}

	public synchronized Object queryRejectedUsers(int prot, String user, UserAccount ua) {
		return queryList(prot, rejectedUsers, user, ua);
	}

	public synchronized Object queryloanRequests(int prot, int id, LoanRequest lr) {
		return queryList(prot, loanRequests, id, lr);
	}

	public synchronized Object accountRequestss(int prot, int id, AccountRequest ar) {
		return queryList(prot, accountRequests, id, ar);
	}

	public synchronized Object queryRollbackRequests(int prot, int id, CancelRequest cr) {
		return queryList(prot, rollbackRequests, id, cr);
	}

	public synchronized Object queryApprovedLoans(int prot, int id, LoanRequest lr) {
		return queryList(prot, approvedLoans, id, lr);
	}

	private <K, V> Object queryList(int prot, Map<K, V> map, K key, V val) {
		synchronized (map) {
			switch (prot) {
			case Constants.PROT_GET:
				return getMap(map);
			case Constants.PROT_ADD:
				return addToMap(map, key, val);
			case Constants.PROT_REMOVE:
				return removeFromMap(map, key);
			}
		}
		return null;
	}

	private <K, V> Object queryList(int prot, Map<K, V> map, K key, Class<V> c, Object... args) {
		synchronized (map) {
			switch (prot) {
			case Constants.PROT_GET:
				return getMap(map);
			case Constants.PROT_ADD:
				return createNewInstance(map, key, c, args);
			case Constants.PROT_REMOVE:
				return removeFromMap(map, key);
			}
		}
		return null;
	}

	private <K, V> Map<K, V> getMap(Map<K, V> map) {
		return map;
	}

	private <K, V> boolean createNewInstance(Map<K, V> map, K key, Class<V> val, Object[] args) {
		Object o = null;
		Class<?> c;
		if (map.containsKey(key))
			return false;

		try {
			c = (Class<?>) args[0];
			o = c.newInstance();
			if (o instanceof UserAccount) {
				((UserAccount) o).setUser((String) args[1]);
				((UserAccount) o).setPass((String) args[2]);
				((UserAccount) o).setBalance((double) args[3]);
				((UserAccount) o).setInterest((double) args[4]);
				((UserAccount) o).setLimit((int) args[5]);
			}
			if(o instanceof AdminAccount) {
				((AdminAccount) o).setUser(user);;
				((AdminAccount) o).setAssociatedAccount();
			}
			if (o instanceof Request) {
				
			}
			if (addToMap(map, key, val.cast(o))) {
				if (o instanceof UserAccount)
					queryUnlockedAccounts(Constants.PROT_ADD, (String) key, (UserAccount) o);
			}
			return true;

		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | SecurityException e) {
			System.out.println(e.getMessage());
			if (Constants.DEBUG)
				e.printStackTrace();
			return false;
		}
	}

	private <K, V> boolean addToMap(Map<K, V> map, K key, V val) {
		if (map.containsKey(key))
			return false;

		map.put(key, val);
		return true;
	}

	private <K, V> boolean removeFromMap(Map<K, V> map, K key) {
		return map.remove(key) != null;
	}

	public void serialize() throws IOException, ClassNotFoundException {
		FileOutputStream fos = new FileOutputStream(new File(modelFile));
		ObjectOutputStream oos = new ObjectOutputStream(fos);

		try {
			oos.writeObject(m);
		} finally {
			fos.close();
			oos.close();
		}
	}

	public boolean beginSession(String user) {
		return sessions.add(user);
	}

	public boolean endSession(String user) {
		return sessions.remove(user);
	}

	private static void deserialize() throws IOException, ClassNotFoundException {
		FileInputStream fis = null;
		ObjectInputStream ois = null;

		try {
			fis = new FileInputStream(new File(modelFile));
			ois = new ObjectInputStream(fis);
			m = (Model) ois.readObject();
		} catch (EOFException e) {
		} finally {
			if (ois != null)
				ois.close();
			if (fis != null)
				fis.close();
		}
	}

	@SuppressWarnings("unchecked")
	public <K, V> boolean checkAuth(String user, String pass, boolean admin) {
		Map<K, V> map;
		map = admin ? (Map<K, V>) admins : (Map<K, V>) users;

		synchronized (map) {
			return map.containsKey(user) && ((Account) map.get(user)).getPass().equals(pass);
		}
	}

	public int getUserStatus(String user) {
		synchronized (users) {
			return users.get(user).getStatus();
		}
	}

	// toString
	@Override
	public String toString() {
		return "Model [users=" + users + ", admins=" + admins + ", rejectedUsers=" + rejectedUsers + ", requests="
				+ requests + ", approvedLoans=" + approvedLoans + "]";
	}

	public boolean attemptRegistration(String user, String pass) throws RegistrationException{
		String lettersUser, numbersUser, specCharsUser;
		String lettersPass, numbersPass, specCharsPass;
		Object o;
		Map<?, ?> m;
		lettersUser = user.replaceAll(letterRegex, "");
		numbersUser = user.replaceAll(numberRegex, "");
		specCharsUser = user.replaceAll(specCharRegex, "");
		lettersPass = pass.replaceAll(letterRegex, "");
		numbersPass = pass.replaceAll(numberRegex, "");
		specCharsPass = pass.replaceAll(specCharRegex, "");
		if(user.length() < Constants.MIN_SIZE_USER || user.length() > Constants.MAX_SIZE_USER ||
				lettersUser.length() < Constants.MIN_LETTER_USER || numbersUser.length() < Constants.MIN_NUMBER_USER ||
				specCharsUser.length() < Constants.MIN_SPEC_CHAR_USER) {
			throw new InvalidUsernameException(user);
		}
		
		if (pass.length() < Constants.MIN_SIZE_PASS || pass.length() > Constants.MAX_SIZE_PASS
				|| lettersPass.length() < Constants.MIN_LETTER_PASS || numbersPass.length() < Constants.MIN_NUMBER_PASS
				|| specCharsPass.length() < Constants.MIN_SPEC_CHAR_PASS) {
			throw new InvalidPasswordException(pass);
		}
		
		o = queryUsers(Constants.PROT_GET, user);
		if(o instanceof Map) {
			if( ((Map<?, ?>) o).get(user) instanceof UserAccount) {
				if(((Map<?, ?>) o).containsKey(user))
					throw new UsernameNotAvailableException();
				queryRequests(Constants.PROT_ADD, 0, 0, ((UserAccount) ((Map<?, ?>) o).get(user)));
			}
		}
		
		return false;
	}

}
