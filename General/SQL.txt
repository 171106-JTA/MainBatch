==========================================
SQL 
==========================================

SQL -> Structured Query Language

Provides commands for building, querying and performing transactions on a database

Relationaly -> The database will have rules to be followed for Structure. 
i.e. how tables relate and react to eachother

Some SQL implementations:
REDBMS examples
Oracle PL\SQL -> Oracle Procedural Langauage SQL: Highest security
Note: the hardest SQL (jerk with syntax)
DBZ: provided by IBM
MySQL: Oracle (maybe open source?)
SQLServer and T\SQL (Transaction SQL): provided by microsoft
PostGres: subjectively the best

Datatypes for Oracle: 
Glob and Clob (we did not talk about this)
- Stores large amounts of data
- Understand differences

==========================================
RDBMS
==========================================
RDBMS 	-> Relational Database Management System
 		-> A type of DBMS. 
 		-> This is a system that aims to provide a user tools for managing a database.
 		-> Its how we relate SQL To databases

==========================================
Database
==========================================
Database -> A structured collection of data

==========================================
Sub-Languages
==========================================
SQL Sublanguages: 
DDL -> Data Definition Language
--- Deals with struturing of actual tables. (Not the data within)
--- Commands: general syntax - <command> <tablename>
		Create		- 	Create a table
		Drop 		- 	Delete a table
		Alter 		- 	Change table
		Truncate 	-	Get rid of all data in the table. Empties the table

DML -> Data Manipulation Language	
--- Deals with CRUD for actual data
--- INSERT -> C
--- SELECT -> R   	grab the data from the table
--- UPDATE -> U 	
--- DELETE -> D

DQL -> Data Querey Language
--- Exists because ???
--- SELECT

DCL -> Data Control Language
--- Deals with data access
--- Who has control over the data
--- GRANT
--- REVOKE

TCL -> Transaction Control Language
--- Deals with everything relating to persisting transactions
--- COMMIT - Saves changes. Until committed, no one can see changes
--- ROLLBACK - Revert to previous commit or savepoint. Cannot only go back to the previous commit...no further
--- SAVEPOINT - Any point after  the last commit that we can roll back to
--- SETTRANSACTION - Sets transaction isolation level
Note: Oracle only supports Serialization and Read Committed

See TechOnTheNet for oracle

==========================================
ERD
==========================================
ERD -> Entity Relation Diagram
Know basic notations
Be able to graph out a diagram

==========================================
CRUD
========================================== 
CRUD -> Create, Retreive/Read, Update, Delete

==========================================
Constraints for ORACLE
==========================================
There are 5 Contraints
Primary Key
- A unique, non-null value in a table
Foriegn Key
- How to make a relationship betwen two or more tables
- A foriegn key must point to either a primary key of another table or a unique key. 
Unique Key
- Must be unique, but can be null
Null/Not Null 
- can be applied to a column to specify if Null is a valid entry or not
Check
- Applies a conditional to a column for the values we insert

Side Note: 
Candidate Key -> Any column that is used to identify others

==========================================
Cascade Constraints
==========================================
CASCADE CONSTRAINTS - Optional. 
Allows tables to be dropped in any order. 
Only use this if you are goind to drop all tables. 
It will delete constraints that point to the table to be 
dropped instead of throwing an error
preventing you from dropping to begin with

==========================================
Referencial integraity: 
==========================================
The enforcement of foriegn key relations. It prevents a user from inserting
a record with an FK that points to a non-existent element. It also prevents
a user from deleting a record that another table points at. 
In additoin, we can't drop a table that another table referecnes
Prevents risk of 'Orphan records'
(i.e. prevents orphan records)
==========================================
AGGREGATE FUNCTIONS
==========================================
An aggregate function is a function applied to a column and processes all the data
returning a single value back. 
Examples: AVG(), SUM(), MAX(), MIN(), STDDEV(), VARIANCE(), LAST(), FIRST(), COUNT()

==========================================
SCALAR FUNCTION
==========================================
A function that applies to each cell of a column. 
e.g. alters the value within each cell of a column
when in doubt, think STring manipulation functions:
lower()
upper()
ABS()
cos,sin,tan()
ROUND()
TRUNC()
CONCAT()
LENGTH()
LTRIM() --TAKE AWAY WHITE SPACE FROM LEFT
RTRIM() --TAKE AWAY WHITE SPACE FROM RIGHT
TRIM() -- BOTH SIDES

==========================================
WHERE vs HAVING
==========================================
WHERE is a conditional that applies to every record individually and will apply 
before a HAVING clause
HAVING is a conditional that aplies to groups of records and take place after filtering
out individual records with WHERE
Since it works on groups of records, it is safe to say, HAVING requires the use of GROUP BY
as well. 
HAVING is also the only way to apply conditions to aggregate

==========================================
JOINS
==========================================

Actual Joins: (i.e. Keywords)
Inner Joins, Outer Joins, Cross Join, Left Join, Right Join
Note: outer join == full outer join

Natural Join - a keyword that can be applied all the 'actual joins'
- i.e. natural right join, natural left join, etc. 
Adding the NATURAL clause to any join requires the ON clause to be ommitted. 
This is because a natural join will join automatically based on matching "Column Name" 
and omit any duplicate column names from the final vieew

Conceptual Joins: 
Self Join, Equijoins, Theta Joins
-------------------------------------------------------------------------

Inner Join 
Combines tables based on column, filtering out data that does NOT appear 
in both tables
(See pg 14 of notebook for example)

Left Join
Grabs all records from the left table iand all corresponding records from the right table. If records do not exist in the right table, columns will be filled 
with NULLs
(Again, pg 14 for example)

Right Join
Same as left for right table. i.e. Grabs all records from the right table
and displays both the right table and corresponding records from the left table
if they exist. 

Full Outer
Grabs data from both tables

Cross Join
Grabs the cartesian product of 2 table. (i.e. the product of the rows...or the combination among all rows in both tables)
The result with be (Table A row_count) * (Table B row_count)

Equijoin
Any time you perform a join where you do tableA.column = tableB.column, you are performing an EQUIJOIN

Thetajoin
Any joins you perform that do NOT use "=" is called a THETAJOIN. 
What does this actually mean?

==========================================
Set Operaions
==========================================
Set operations aim to combine and filter the data between queries (note: DO NOT ever use the work 'table' when talking about Set Operations)

Rules for set operators
The two queries must have matching column counts, as well as the column datatypes being presented in the same order. column names do not have to match.
It will just take the names of the left query anyway. 


Unions, Union All, Intersect, Minus
------------------------------------------------------------------------
Unions -> return a combination of all distict records
Distict -> no dublicates

Union All -> same as union but includes duplicates

Intersect -> Filters out all records that weren't in both tables

Minus -> Removes any records from the left query that appears in the right query

NOT SUPPORTED BY ORACLE:
Except -> returns all records that are exclusive to one side



==========================================
Difference Questions (i.e. What is the Defference between ____ and )
==========================================

Intersect VS InnerJoin
What is the difference between Intersect and InnerJoin?
InnerJoin -> the combining of two table based on a column
Intersect -> compares two queries and compares eleemnts of records
The datatypes in Intersect queries must match across columns...the column names do not need to match

what is the difference between Full Outer Join and a Union All (or Union)?

Note: you can always replicate the results using either joins or sets

Joins Vs Sets
Joins 
take 2 tables and join on a column. i.e. the tables have a column name and datatype in common. Combines all columns together
Sets
Query 2 tables and get a result set. Take those 2 result sets and combine them. 
Can only join if column count and column datatype order match. 

==========================================
Normalization
==========================================
Normalization -> levels of structure to reduce database ambiguity and redundancy

==========================================
Atomic Data
==========================================
Atomic Data -> data at its lowerst detailed form

==========================================
Keys
==========================================
Primary Key -> 
Foriegn Key -> 
Candidate Key -> Any column that is used to identify others

==========================================
PL/SQL
==========================================
Oracle has an extension called PL/SQL
Procedural Language/Structured Query Language\
- Provided tools that we can use with SQL including
-- Functions
-- Stored Proecdures
-- Sequences
-- Triggers
-- Also provides a means to write actual code inside SQL scripts

Sequence
A Sequence is an obejct that will maintain a counter for you

TRIGGER
A trigger is an object we can create that waits for actions to occur on the 
specific table the trigger was made for
A trigger can be coded to react to most CRUD operations. (Excluding select)

Select Into statment
- A Select Into STatement will grab data and place it into a variable
In PL/SQL there exists implicit objects that we can use to access data
These object are all preceeded with a colon ':'. 
In the above example we accessed :NEW, which points to the current record 
that is about to be inserted. This lets us manipulate data before it gets
inserted. :NEW can be compared to a staging platform
   
DUAL 
DUAL is a dummy table that is always available. It's only purpose is to allow 
a develop to have proper syntax in statements where the table does not matter. 

Stored Procedure
A Stored Procedure is a named transaction that can be invoked when called. 

Procedure can allow us to define executions that can change the data. 
Most actions can be taken against a table using procedures. 

Things of note: 
Parameters in stored procedures are a bit unique. 
YOu have to use the follwoing keywords: IN, OUT, IN OUT.
IN parameters -> whatever is passed as input during the procedure call
OUT parameters -> whatever is returned from the procedure. 
IN OUT parameters -> a parameter passed in then changed. 


Procedure Syntax
CREATE [or REPlACE] proc-name
IS
    [This section is where you can DECLARE variables]
BEGIN
    This section is where you can write the execution
[EXCEPTION]
    You can perform exception handling here. 
END; 

you can invoke a stored procedure in two ways: 

BEGIN
    proc-name();
END; 

--Or 

call proc-name();

 CURSORS: 
- a CURSOR IS ESSENTIALLY LIKE A POINTER TO A TABLE OR VIEW
- WE CAN USE THEM TO ITERATE THROUGH INTIRE QUERIES FORM THE DATABASE
- When we want to pass entire tables or queries, we need to use cursosrs. 

Note: PL/SQL offers a CURSOR and a SYS_REFCURSOR
The SYS_REFCURSOR is a stronger cursor (Therefore more costly) that is allowed
to be passed outside of the scope of the procedure it's in. A normal CURSOR must 
be created and die within the scope of the procedure that is was created in.

Function VS Procedure
A function differs from a stored procedue in the following ways: 
A stored procedure does not have to return anything
A stored procedure CAN have as many IN/OUT parameters as it wants
A stored procedure CAN alter the database such as insert, delete, ect.
A stored procedure CANNOT be called mid-query
We can call a stored procedure from a stored procedure
A stored procedur can call functions

A function MUST return one and only one thing
A function CAN use OUT parameters, but this is highly advised against
A funciton CANNOT perfomr database operations. 
A function CAN be called mid-query
a function can call other functions
A function cannot call a stored procedure 
- (because functions cannot change a database and stored procedures can)


In vs exists
- both these commands can be used to perform conditional checks
- high level overview: EXISTS is garbarg...highly inefficient if the outer query is even remotely large


==========================================
Cardinality and Multiplicity
==========================================
Cardinality -> the relationships amoung tables
One to One -> (1,1), Only used when you want to split a table up 
(i.e. in general is you see an FK, PK column, its a one to one relationship)
One to Many -> (1, M)
Many to One -> (M, 1)
Many to Many -> (M, N), Use join tables to implement
(In general, if you see 2 FK in a table, it might be a join table for a many-to-many relationship)

Multiplicity -> the specific limitations on a relationship 
Zero to 1 
1 to M
1 to 1

==========================================
Join Tables 
==========================================
Holds only foreign keys to relate one table to another. Use for many-to-many relationships

==========================================
Lookup Tables
==========================================
Used to abstract status-type information. 

======================================
Indices
======================================

CREATE INDEX <INDEX_NAME> ....

INDEX is an object that can be used to index every record in a table based off your choice of column
SQL will create an object that uses it's own system to index each record in a table

Pros: 
Indexing stops SQL from having to scan the entire table for whatever information it needs
- i.e. drastically speed up scanning a table
- in this case, we have a non-clustered index
Indicies drastically reduce the time it takes to query a table

Cons: 
CRUD operations take longer with an index involved

Clustered Index
- An index which uses the actual values of a column to index the table
- Primary keys are clustered indices by default

======================================
Transaction
======================================
An atomic unit of work on a table

======================================
ACID
======================================
Properties of a transaction

A -> Atomicity
- In short: All or nothing
- If at any point during a transaction an issue occurs, the entire transaction is aborted

C -> Consistency
- Any one transaction should yeild the same result whenever it is executed
- Expand this!

I -> Isolation
- Any 2 or more transactions must NOT affect eachother

D -> Durability 
- All data must be persisted
- If a database crashes, no data should be lost

======================================
Risks Of Multiple Users
======================================
Dirty Read
- Grabbing any uncommitted changes
- Prevented by putting a READ LOCK on the table

Non-Repeatable Reads
- When you read a record twice in one transaction and the results are different
- Prevented by putting a WRITE LOCK

Phantom Read
- When you query a table multiple times in one transaction and the amount of records are different
- Prevented by putting a TABLE LOCK on the table

======================================
Transaction Isolation Levels
======================================

						Dirty Reads 	| 	Non-Repeatable Reads 	| 	Phantom Reads
________________________________________________________________________________________
Read uncommitted 	|		X			|			X				|		X
________________________________________________________________________________________
*Read Committed		|					|			X				|		X
________________________________________________________________________________________
Repeatable Reads	|					|							|		X
________________________________________________________________________________________
*Serializable		|					|							|
________________________________________________________________________________________

Oracle only supports Read Committed and Serializable
We can set the transaction level using the SET TRANSACTION from the TLC sub-language for ORACLE

======================================
Denormalization
======================================
Denormalizing our tables
Used for data warehouses and data mining

Online Analytical Processing (OLAP)
- Denormalize
- Designing database for analysis
- Data warehousing
- Slaes, profits, Business Patterns
Online Transaction Processing (OLTP)
- Use 3NF
- Used for actual application structure
- List choices, user credentials, etc. 
- Star Schema and Snowflake schema (See pg 17 of notebooks for examples)

======================================
JDBC
======================================
JDBC -> Java Database Connectivity
- Basically the DAO layer 

Architecture -> See pg 18 of notebook

Components of the JDBC: 6 of them
DriverManager 			-> Manages a list of database drivers
Driver 					-> Interface that handles communications with the DB
Connection Interface	-> All communications with the database revolve around this component
						-> The bridge between us and our database
Statement 				-> Objects that are used to submit SQL Statements
						-> Executes all CRUD operations
ResultSet 				-> Results from querying a database.
						-> Stores received data
SQLException 			-> Translation of database errors to Java Exceptions

****************
know the architecure of jdbc + its components
****************

======================================
Star/snowflake schema
======================================
-> See pg 17

======================================
sub queries
======================================

======================================
statement, preparedstatement, callablestatement
======================================

sql injection